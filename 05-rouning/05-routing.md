# routing

Зміст:

- [routing](#routing)
- [придумуєм свій роутер](#придумуєм-свій-роутер)
- [react-router vs react-router-dom](#react-router-vs-react-router-dom)
- [встановлення](#встановлення)
- [обʼєкт роута:](#обʼєкт-роута)
- [підхід з масивом роутів](#підхід-з-масивом-роутів)
    - [вкладені роути](#вкладені-роути)
    - [грьобаний `Outlet`](#грьобаний-outlet)
- [підхід з компонентами `Route` та `Switch`](#підхід-з-компонентами-route-та-switch)
    - [вкладені роути ще раз](#вкладені-роути-ще-раз)
- [хуки](#хуки)

як тобі уже, певно, відомо, на React-і люди пишуть так звані `Single Page Application`, що в перекладі з ельфійської на людську означає - `Одна Сторінка Застосунок`. ну шо, стало зрозуміліше? ага, і я ж про то.

`SPA` (Single Page Application) - означає що вся величність веб-застосунку буде показана користувачу на одній лише сторінці. саме з цієї причини в ініціалізаційних файлах проєкту є тількти один `html` файл.

на питання **_"а нахіба?"_** відповідь проста - щоб користувач не чекав по декілька секунд наперезавантаження сторінки кожен раз як тицяє шось на екрані.

для того і потрібен `routing` - менеджити яку "сторінку" зараз показати, коли прибрати контент однієї сторінки і підкинути наступну, тощо.

# придумуєм свій роутер

в цілому, якшо трохи напрягти булки, то ти уде на даному етапі можеш самостійно написать собі свій роутер і кайфувать це життя, розповідаючи байки про те шо ти нахєрачив самотужки кастомну бібліотеку для роутінгу.

тому перед тим, як вивчати якусь сторонню, давай спробуємо написати свою. я писатиму все в одному файлі, бо в такому формати зручніше показувати, ти ж можеш рзнести це все на декілька, фактично не вплине на роботу.

```tsx
// всьо шо потрібно нашому роуту це шлях та компонент який він має показати
type Route {
  path: string
  component: FC<any>
}

type RouterProp {
  routesList: Array<Route> //тип для роута напишемо трошки далі
}

// по суті все шо треба, це просто отримати список роутів і фсьо
const Router:FC<RouterProp> = ({routesList}) => {
  const [currentRoute, setCurrentRoute] = useState<string>('/')
  const activeRoute = routesList.find(route => route.path === currentRoute)
  const SingleRoute = activeRoute.component

  const handleRouteChange = (route:string) => {
    //захист від дібіла. коли нема такого роута, то і показувати нічого
    if(!routesList.find(route => route.path === route)) throw new Error('route not found')

    window.history.pushState({}, '', route) //міняємо адресу в браузері
    setCurrentRoute(route)
  }

  return <SingleRoute isCurentRoute={true} navigate={handleRouteChange}/>
}
```

тепер трохи пояснень як це працює:

- `routesList` - масив обʼєктів типу `Route`, де кожен обʼєкт має шлях та компонент який він має показати за цим шляхом
- `activeRoute` - обʼєкт типу `Route`. той з обʼєктів з `routesList`, `path` якого співпадає з `currentRoute`
- `SingleRoute` - компонент який треба відрендерити на екрані
- `handleRouteChange` - функція яка змінює `currentRoute` на строку, яку їй передали, а також міняє адресу в браузері і плюється помилкою, якщо роута з такою адресою немає в `routesList`
- Компоненту кожного з роутів у списку `routesList` ми 100% передамо два пропси:
  - `isCurentRoute` - чи цей роут зараз активний,
  - `navigate` - функція яка змінить `currentRoute` на ту, яку їй передали

використання нашого `Router`-а виглядатиме приблизно так:

```tsx
const Home = () => <h1>Home</h1>
const About = () => <h1>About</h1>
const Contacts = () => <h1>Contacts</h1>

const App = () => {
  const routesList = [
    { path: "/", component: Home },
    { path: "/about", component: About },
    { path: "/contacts", component: Contacts },
  ]

  return <Router routesList={routesList} />
}
```

дас іт, фініта ля комєдія. роутер з мінімально можливим набором функціоналу написано.

в корнях кожної бібліотеки для роутінгу знаходиться точнісінько така сама ідея. єдина різниця між оцим мінімальним роутером і тим, щов бібліотеці - додатковий функціонал, до якого прийшли ітератвним підоходом розумні дядьки для того шоб тобі було зручніше коли настане час користуватись всім що необхідно для роботи з роутінгом.

# react-router vs react-router-dom

колись за часів раннього палеоліту у реакт розробці, треба було руцями встановлювати обидві бібліотеки та ще і пам'ятати:

- `react-router` - все шо виглядає, назване та працює як **функція** - `createBrowserHistory`, `navigate`, `useLocation`, тощо
- `react-router-dom` - все шо виглядає, назване та працює як **компонент** - `BrowserRouter`, `Route`, `Link`, тощо

як і все в розробці, такий надзвичайно складний підхід фронтендним мавпо-розробникам здавався нереальним для запамʼятовування та на стіки не зручним для роботи шо у люде вилазили очі, зʼявлялись ракові пухлини, зникав сон та спокій.

тому Боженька пожалів людство і вирішив зробити так, щоб `react-router-dom` був просто обгорткою навколо `react-router` та встановлював його автоматично. тепер тобі не потрібно пам'ятати про дві бібліотеки, тобі потрібно пам'ятати тільки про одну.

торжество прогресу розуму та еволюціі людства осьо прямо перед тобою, бeри нюхай та насолоджуйся ароматом!

# встановлення

найпопулярніша [бібліотека](https://reactrouter.com/en/main/start/tutorial) для роутінгу на React-і. вона має величезну кількість документації та підтримку від команди React.

```bash
npm install react-router-dom
```

або

```bash
yarn add react-router-dom
```

далі все не так просто як може здатись на перший погляд, проте пірнатимемо в деталі по черзі.

є два підходи як створити роутінг в твоємо зустасунку

- передавать список роутів у вигляді масиву обʼєктів, як ми робили це вище в самописному роутері
- використовувати компоненти `Route` та `Switch` для визначення роутів

вади та переваги кожного з підходів штука знову ж таки холіварна. хтось любить робить всяке лівою рукою, комусь зручніше правою це справа така.

# обʼєкт [роута](https://reactrouter.com/en/main/route/route):

ми з тобою писали простецький роутер, там у одного роута було всього 2 властивості. у випадку з біблотекою їх дещо більше.

```tsx
{
  // тут все понятно - компонент який тре показать коли користувач на вказаному шляху знаходиться
  element: <Contacts />,

  // власне шлях до роуту
  path: "/contacts",

  /**
   * функція, що "завантажує" дані з якими буде відрендерений компонент
   * request - обʼєкт з запитом, який можна використати для відміни запиту
   * params - обʼєкт з параметрами шляху, де будуть в тому числі параметри та змінні шляху, якими можна користуватись
   * */
  loader: async ({ request, params }) => {
    return fetch(`/fake/api/contacts-list`, {
      signal: request.signal,
    }).then((res) => res.json())
  },

  /**
   * функція, що буде викликана коли хтось сабмітить дані на цей роут.
   * в перекладі з ельфійської - коли хтось засабмітив форму, в action атрибуті якої був оцей роут (в нашому випадку "/contacts")
   *
   * request - обʼєкт з запитом, який можна використати для відміни запиту
   * */
  action: async ({ request }) => {
    return updateFakeContact(await request.formData())
  },

  // передаєш сюди компонент який треба відрендерити якщо компонент склеїв ласти
  errorElement: <ErrorBoundary />,
},
```

тепер розкинь головою скіки треба було б часу витратити щоб самотужки змусити такий конфіг працювати. а у тебе воно є, осьо доступне, качай, доку читай та користуйся.

# підхід з масивом роутів

цей підхід максимально схожий на те що ми робили в самописному роутері, проте властивостей у обʼєкту одного розута може буть трошки більше і вони додають прикольного функціоналу.

я з таким варіантом зустрівся, коил писав на

```tsx
const router = createBrowserRouter([
  {
    path: "/",
    element: <div>Home page</div>,
  },
  {
    path: "/about",
    element: <div>About page</div>,
  },
  {
    path: "/contacts",
    element: <div>Contacts page</div>,
  },
])

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <RouterProvider router={router} />
  </React.StrictMode>
)
```

як бачиш, суть максимально схожа, але трошки відрізняються назви. страшного нічо нема.

єдина критична відмінність це шматочок з викликом `ReactDOM.createRoot()`. ця функція викликається один раз на весь проєкт. виклик знаходиться у файлі `main.js` або `main.ts` або `index.ts` або `index.js`.

[`RouterProvider`](https://reactrouter.com/en/main/routers/router-provider) - компонент який відповідає за все дерево роутінгу твого веб-застосунку. це по суті дуже наворочена та напічкана логікою версія компоненту [`Router`](#придумуєм-свій-роутер) який ми писали вище.

### вкладені роути

припустимо у тебе є до прикладу сторінки:

- `/home` - головна сторінка
- `/contacts` - посилання на всі наші соцмережі в комбінації з картою та нашими хлібальниками
- `/about` - сторінка щ довжелезним текстом про то які ми круті
- `/albums` - всі альбоми поточного користувача
- `/slbum/:id` де `:id` - це динамічний параметр шляху, тобто в браузері на місце `:id` буде підставлені айдішка альбому, щоб завантажити фотографії саме конкретно цього альбому.

тоді в нагоді стає властивість `children` обʼєкту кожного роута, в яку можна передати масив роутів. таким чином можна побудувати цілу ієрархію.

```tsx
const router = createBrowserRouter([
  {
    path: "/",
    element: <h1>Home page</h1>,
    children: [
      {
        path: "/contacts",
        element: <h1>Contacts page</h1>,
      },
      {
        path: "/about",
        element: <h1>About page</h1>,
      },
      {
        path: "/albums",
        element: <h1>Albums page</h1>,
        children: [
          {
            path: "/:id",
            element: <h1>Album page</h1>,
          },
        ],
      },
    ],
    ]
  },
])
```

### грьобаний [`Outlet`](https://reactrouter.com/en/main/components/outlet)

[отут](#вкладені-роути) ми запхали в `children` головного кореневого роуту всі інші дочірні.

сюрпрайз-сюрпрайз, ніхєра не буде рендеритись нормально на стрінці.

бо шо? бо для коректної роботи треба користуватись компонентом [`Outlet`](https://reactrouter.com/en/main/components/outlet) який відповідає за рендер всіх дочірніх роутів.

тому кореневий компонент твого проєкту буде виглядати приблизно так:

```tsx
const App = () => {
  return (
    <div>
      <p>Header</p>
      <Outlet />
      <p>Footer</p>
    </div>
  )
}
```

# підхід з компонентами `Route` та `Switch`

просто перепишемо структуру роутів з [попереджнього розділу](#підхід-з-масивом-роутів) і тобі стане в цілому все зрозуміло.

```tsx
const AppRouter = () => {
  return (
    <Switch>
      <Route path="/" element={<h1>Home</h1>} />
      <Route path="/about" element={<h1>About</h1>} />
      <Route path="/contacts" element={<h1>Contacts</h1>} />
    </Switch>
  )
}

const App = () => {
  return <AppRouter />
}
```

пропси у компоненту `Route` такі самі як і в обʼєкті роута.

`Switch` - компонент який відповідає за вибір роута для відображення. по суті працює так само як оператор `switch`, тобто спрацьовуватиме лише один з усіх переданих варіантів, тобто лише той `Route`, пропса `path` якого співпадає з поточним шляхом.

### вкладені роути ще раз

знову просто переписуємо те, що [уже було](#вкладені-роути)

```tsx
const AppRouter = () => {
  return (
    <Switch>
      <Route path="/" element={<h1>Home</h1>} />
      <Route path="/about" element={<h1>About</h1>} />
      <Route path="/contacts" element={<h1>Contacts</h1>} />

      <Route path="/albums" element={<h1>Albums</h1>}>
        <Route path="/:id" element={<h1>Single Album</h1>} />
      </Route>
    </Switch>
  )
}
```

# хуки

тобі мають бути знайомі уже `useState` та `useEffect`. бібліотека роутінгу має свої хуки, написані для поліпшення твого життя розумними дядьками.

тут я переахую лише декілька основних, бо їх насправді чимало і далеко не всі з них використовуються достатньо часто шоб забивати зараз ними твою голову.

- [`useNavigate`](https://reactrouter.com/en/main/hooks/use-navigate) - повертає функцію для зміни поточного роута
- [`useNavigation`](https://reactrouter.com/en/main/hooks/use-navigation) - дає тобі обʼєкт з повним набором інмормації про загальну навігацію проєкту
- [`useParams`](https://reactrouter.com/en/main/hooks/use-params) - повертає обʼєкт з параметрами шляху
- [`useSearchParams`](https://reactrouter.com/en/main/hooks/use-search-params) - повертає обʼєкт з параметрами шляху, тобто з усіма оцими змінними що написані в URL після знаку `?`
- [`useLocation`](https://reactrouter.com/en/main/hooks/use-location) - повертає обʼєкт з поточним шляхом
- [`useLoaderData`](https://reactrouter.com/en/main/hooks/use-loader-data) - повертає дані, які були завантажені для рендеру компонента у властивості `loader` обʼєкту роута
