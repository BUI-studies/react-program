# Життєвий цикл компонента

Зміст:

- [Життєвий цикл компонента](#життєвий-цикл-компонента)
- [Mounting](#mounting)
  - [constructor](#constructor)
  - [static `getDerivedStateFromProps`](#static-getderivedstatefromprops)
  - [render](#render)
  - [componentDidMount](#componentdidmount)
- [Updating](#updating)
  - [shouldComponentUpdate](#shouldcomponentupdate)
  - [componentDidUpdate](#componentdidupdate)
- [Unmounting](#unmounting)
  - [componentWillUnmount](#componentwillunmount)
- [Шо по послідовностях?](#шо-по-послідовностях)
- [Хуки](#хуки)
  - [я милого впізнаю за ходою](#я-милого-впізнаю-за-ходою)
  - [так все ж таки шо роблять хуки?](#так-все-ж-таки-шо-роблять-хуки)
  - [кастомні хуки](#кастомні-хуки)
    - [useLocalStorage](#uselocalstorage)
    - [useWindowSize](#usewindowsize)
- [А як у функціональних компонентах?](#а-як-у-функціональних-компонентах)
  - [useEffect з пустим масивом залежностей](#useeffect-з-пустим-масивом-залежностей)
  - [useEffect зі змінними в масиві залежностей](#useeffect-зі-змінними-в-масиві-залежностей)
  - [return value функції переданої в useEffect](#return-value-функції-переданої-в-useeffect)
  - [а як тоді імітувати `shouldComponentUpdate`?](#а-як-тоді-імітувати-shouldcomponentupdate)
- [ErrorBoundary](#errorboundary)

Перше що треба зрозуміти про життєвий цикл, це те, що пояснювати його на класах набагато простіше. Якими б застарілими та повільними класові компоненти не були, кожен з них мав усі потрібні методи життєвого циклу, роботу яких перевірити було максимально просто.

Тому пояснення основних важливих методів життєвого циклу буде наведено на прикладі класового компонента.

Далі, під кінець, уже розберемось шо з них і як працює для функціональних.

Кожен метод на кожній стадії представлений реальним методом класового компоненту, який реакт "смикатиме" у зазначений момент. Тобто знаючи ці методи, їх назви і моменти в які вони будуть викликані, ти отримуєш суперсилу - розуміння куди шо запхать залежно від того коли тобі потрібно шоби щось виконалось.

# Mounting

Це покишо не метод, а стадія життєвого циклу. Трошки вища абстракція над методами. Можеш собі уявляти це як групу методів.

Під час стадії mounting відбувається створення компонента та його відображення на сторінці. Це перший етап життєвого циклу компонента.

## constructor

шо тут пояснювать? перед тим як на екран шось виплюнуть, треба спочатку створити екземпляр компоненту.

як ти створюєш екземпляр об'єкта в js? правильно, через конструктор. тут все так само.

конструктор викликається один раз, в самому початку життя компоненту. тут можна ініціалізувати стейт, або зробити щось інше, що треба зробити один раз при створенні екземпляру.

```jsx
class MyComponent extends Component {
  constructor(props) {
    super(props) //оця штука викликає конструктор "батьківського" компоненту, тобто реактівського Component
    this.state = {
      //тут можна ініціалізувати стейт
    }
  }
}
```

## static `getDerivedStateFromProps`

Просто візьми і переклади назву, більшість суті вона пояснює самостійно без додаткових втручань.

Цей метод викликається перед рендером, коли компонент отримує нові пропси. Він повертає новий стейт, який буде використаний для оновлення стейту компонента.

`static` - лише означає, що для виклику цього методу не потрібно створювати екзеспляр класу. Можна вилкикати через крапку після імені класу.

використовувався дуже рідко, коли треба втрутитись в процес оновлення стейту, який відбувається після отримання нових пропсів.

## render

з назви, знову таки має бути очевидно шо відбувається.

з цікавого:

- єдиний обовʼязковий метод у класового компонента
- не завершиться, поки не завершаться рендери всіх дочірніх компонентів

```jsx
class MyComponent extends Component {
  render() {
    return <div>{/* тут відображається компонент */}</div>
  }
}
```

## componentDidMount

досить популярний метод, викликається один раз, після того як компонент відобразився на сторінці.

зазвичай перший рендер компонента відбуваєтсья "впусту" без даних, потім викликається componentDidMount, де уже можна робити запити на сервер, і тільки потім відбувається оновлення стейту, яке призведе до другого рендеру з даними.

```jsx
class MyComponent extends Component {
  componentDidMount() {
    //тут можна робити запити на сервер, або щось інше, що треба зробити після того як компонент відобразився на сторінці
  }
  render() {
    return <div>{/* тут відображається компонент */}</div>
  }
}
```

# Updating

методи даної стадії викликаються після одного з тригерів:

- зміни пропсів
- зміни стейту
- виклик `forceUpdate` - на практиці зустрічається так само часто, як чесні політики

## shouldComponentUpdate

з назви стає зрозуміло, шо від цього козака залежить чи дійсно буде оновлюватись компонент. тобто тут ти можеш втрутитись в процес порівняння стврих пропсів та нових, або стейту до і після оновлення.

якщо метод поверне `false`, компонент не буде оновлений.

```jsx
class MyComponent extends Component {
  shouldComponentUpdate(nextProps, nextState) {
    //тут можна втрутитись в процес оновлення компонента
    return true //повернути false, якщо не треба оновлювати компонент
  }
  render() {
    return <div>{/* тут відображається компонент */}</div>
  }
}
```

## componentDidUpdate

викликається після оновлення компонента. випадки його застосування досить рідкісні, бо важко видумать випадок коли тобі треба відправити запит на сервер, основуючись на тому що стейт або пропси апдейтнулись.

проте воно є, ним можна скористатись в класовому компоненті

# Unmounting

## componentWillUnmount

метод, в якому саме час відписуватись від підписок, видаляти таймери, або будь-які інші дії перед видаленням компонента зі сторінки.

# Шо по послідовностях?

Якшо ми забудемо про стадії, то послідовність спрацьовування методів приблизно така:

- constructor
- static `getDerivedStateFromProps`
- render
- componentDidMount

і середньостатистичний `stateless` компонент на цьому етапі тупо чекатиме тіки на `componentWillUnmount`.

але якщо ж помінялись пропси, або стейт, то кожного разу, кожної зміни наступна послідовність:

- static `getDerivedStateFromProps`
- shouldComponentUpdate
- render
- componentDidUpdate

# Хуки

один з них тобі уже знайомий - `useState`. він та його брати по зброї були створені з дуже шляхетною, проте не менш лицемірною місією - за`/&@`рити стейт у `stateless` компонентах.

функціональні компоненти в свому первозданному вигляді сильнотяготіли до поняття `чиста функція`, бо були здатні лише приймать пропси, та відображати на екрані шось із ними повʼязане.

> `чиста функція` - це така функція, що не має зовнішніх залежностей та завжди повертає однаковий результат при однакових вхідних даних.

станом на сьогодні, в світі фронтенд розробки парадигмою функціонального програмування не захоплюється тіки той, хто ще не потрапив у сферу. багато чого в цій парадигмі свідчить про те, що в ідеальному світі де є єдинороги, нема збройних конфліктів, всі один одного люблять та ніхто ніколи не бреше, все має бути написане на чистих функціях.

і от де ховається лицемірство - у світі, де все має якомога ближче стрімко бігти в сторону чистих функцій ми пишемо компоненти, які залежні від зовнішніх змінних так, як доля Нідерландів від погодних умов регіону.

а все тому, що `хук` - це функція, написана десь в іншому місці, якимись там руками, від існування і роботи якої стає залежним наш компонент в той самий момент як тільки ми пишемо назву хука.

таким чином, функціональні компоненти зі стейтом вигядають як героінові наркомани в порівнянні такими ж функціональнми але `stateless` компонентами.

## я милого впізнаю за ходою

шоб зрозуміти шо перед тобою хук тре впевнитись, що:

- це функція
- ця функція щось повертає
- назва починається з `use`
- ця функція викликана в тілі компоненту ДО `if`-ів, `switch`-ів або циклів

## так все ж таки шо роблять хуки?

вони як плагіни у VSCode - додають до твого компоенту якісь супер-сили, які до цього були неможливі. як от - використання стейту, доступ до параметрів шляху з адресної строки браузеру, тощо.

## кастомні хуки

все що треба - правильно назвати, придумати яка саме логіка буде міститись всередині та не забути `return value`.

### useLocalStorage

яскравим і водночас корисним прикладом для мене є хук `useLocalStorage`, яким я особисто досить часто користуюсь

```tsx
const useLocalStorage = (key, defaultValue) => {
  const [localStorageValue, setLocalStorageValue] = useState(() => {
    try {
      const value = localStorage.getItem(key)

      if (!value) {
        localStorage.setItem(key, JSON.stringify(defaultValue))
        return defaultValue
      } else {
        return JSON.parse(value)
      }
    } catch (error) {
      localStorage.setItem(key, JSON.stringify(defaultValue))
      return defaultValue
    }
  })

  const changeValue = (newValue) => {
    localStorage.setItem(key, JSON.stringify(newValue))
    setLocalStorageValue(newValue)
  }

  return [localStorageValue, changeValue]
}
```

### useWindowSize

час від часу стає в нагоді, коли до прикладу на мобілках та десктопах треба відрендерити різні компоненти

```tsx
const useWindowSize = () => {
  const [windowSize, setWindowSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight,
  })

  useEffect(() => {
    const handleResize = () => {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight,
      })
    }

    window.addEventListener("resize", handleResize)

    return () => {
      window.removeEventListener("resize", handleResize)
    }
  }, [])

  return windowSize
}
```

як бачиш, користуватись `localStorage` з цим хуком стає зручніше, бо тепер зміна ключа в `localStorage` зпричинятиме і зміну стейту компонента, який використовує хук, а значить і перерндерить компонет без додаткових втручань.

# А як у функціональних компонентах?

тут все цікавіше і на мій особистий погляд трошки костильніше виглядає.

- по-перше усього різноманіття впливу як в класових компонентах - тут нема.

- по-друге - вся взаємодія з життєвим циклом сидить на використанні hook-а `useEffect`. від того що як і в якій послідовності ми в нього передаємо, змінюватиметься момент, коли переданий нами код спрацьовуватиме.

- по-третє - тіки присядь, бо впадеш. мільйони гайдів та відосів говоритимуть шо **користуватись `useEffect`-ом не можна**, що це минулий вік, що так уже ніхто не робить, що це шкодить продуктивності, лунним фазам Сатурна і таке інше.

  насправді ці ідіоти мають на увазі, що **запховувати `useEffect` безпосередньо в код компонента - це така собі ідея**.

  під капотом усіх рішень, які позбавляють тебе використання `useEffect`-у, насправді лежить...барабанний дріб...`useEffect`! та, це абсурд і маразм на перший погляд, проте памʼятай що ідея саме в тому, щоб винести `useEffect` за межі тіла компоненту, тоді вся ця богохульна магія виглядатиме набагато більш зрозумілою.

- по-четверте - `useEffect`-у треба ЗАВЖДИ передавати масив залежностей. хай навіть пустий, але другий аргумент має буть масив. інакше адекватної роботи від нього ти не дочекаєшся.

## useEffect з пустим масивом залежностей

`useEffect` з пустим масивом залежностей викликається тільки один раз, після першого рендеру компонента. тоюто повністю імітує поведінку `componentDidMount`.

```jsx
const MyComponent = props => {
  useEffect(() => {
    console.log('я в консолі буду тіки один раз після того як компонент відрендериться вперше')
  }, [/*пустий масив залежностей*/])

  return <p>
    Hello World
  </p>
```

## useEffect зі змінними в масиві залежностей

callbackб який ти передаєш в `useEffect` викликається кожного разу, коли змінюється хоча б одна змінна з масиву залежностей. тобто повністю імітує поведінку `componentDidUpdate`.

```jsx
const MyComponent = props => {
  const [count, setCount] = useState(0)

  useEffect(() => {
    console.log('я в консолі буду викликатись кожного разу, коли зміниться count')
  }, [count])

  return <p>
    <button onClick={() => setCount(count + 1)}>Click me</button>
  </p>
```

приклад, очевидно, нежиттʼздатний, проте направлений лише показати тобі як це працює. де приміняти цей прийом ти відпрацюєш на практиці трохи згодом.

## return value функції переданої в useEffect

функція, яку ти передаєш в `useEffect` може повертати ще одну функцію.

не питай нахєра так складно, це треба прийняти як аксіому. нахєра вони зробили це так "зручно" ніхто не знає.

так от ця друга функція, яку твій callback може повернути повністю імітуватиме `componentWillUnmount`.

```jsx
const MyComponent = props => {
  const [count, setCount] = useState(0)

  useEffect(() => {
    console.log('я в консолі буду викликатись кожного разу, коли зміниться count')

    /* оця функція і буде викликана на етапі Unmount */
    return () => {
      console.log('а я імітую componentWillUnmount')
    }
  }, [count])

  return <p>
    <button onClick={() => setCount(count + 1)}>Click me</button>
  </p>
```

## а як тоді імітувати `shouldComponentUpdate`?

для цього Боженька придумав `prevState`. це коли ти замість значення в `setState` передаєш функцію, яка приймає попередній стейт, і повертає новий.

```jsx
const MyComponent = props => {
  const [count, setCount] = useState(0)

  const handleIncrement = () => {
    /*бачиш, замість значення передаю функцію і творю там шо хочу у перевірках*/
    setCount(prevState => {
      if(prevState >= 100) return 0
      return prevState + 1
    })
  }

  return <p>
    <button onClick={handleIncrement}>Click me</button>
  </p>
```

також, для схожого ефекту можна використати `useMemo` або `useCallback`, але це вже зовсім інша історія.

# [ErrorBoundary](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)

а це штука, яку можна створити лише класовим компонентом, бо тільки він має метод `componentDidCatch`.

служить добру службу по красівому відображенню помилок в додатку, які користувачеві все ж мають бути показані. та, під час розробки ти і так побачиш гарний UI на екрані, коли щшось гепнеться, але ця дає тобі контроль над тим що побачить користувач на продакшені, після того як весь додаток буде зібрано та задеплоєно.

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props)
    this.state = { hasError: false }
  }

  static getDerivedStateFromError(error) {
    // оновлюємо стейт для того, щоб потім відрендерити UI з помилкою
    return { hasError: true }
  }

  componentDidCatch(error, info) {
    // Example "componentStack":
    //   in ComponentThatThrows (created by App)
    //   in ErrorBoundary (created by App)
    //   in div (created by App)
    //   in App
    logErrorToMyService(error, info.componentStack) // це на віпадок, якщо у тебе є підключений сервіс із логуванням помилок
  }

  render() {
    if (this.state.hasError) {
      // це може бути будь яка розмітка зі стилями на твій смак
      return <h1>Something went wrong.</h1>
    }

    return this.props.children
  }

  logErrorToMyService() {
    // тут можна відправити помилку на сервер
  }
}
```

на практиці зустрічається, але зазвичай або автогенерується бандлером, або уже написаний до тебе. проте розуміти шо в ньому відбувається та чому потрібно, аби не ввести себе в оману шо магія існує.
