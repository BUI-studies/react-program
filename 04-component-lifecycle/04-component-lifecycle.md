# Життєвий цикл компонента

Зміст:

- [Життєвий цикл компонента](#життєвий-цикл-компонента)
- [Mounting](#mounting)
  - [constructor](#constructor)
  - [static `getDerivedStateFromProps`](#static-getderivedstatefromprops)
  - [render](#render)
  - [componentDidMount](#componentdidmount)
- [Updating](#updating)
  - [shouldComponentUpdate](#shouldcomponentupdate)
  - [componentDidUpdate](#componentdidupdate)
- [Unmounting](#unmounting)
  - [componentWillUnmount](#componentwillunmount)
- [Шо по послідовностях?](#шо-по-послідовностях)
- [А як у функціональних компонентах?](#а-як-у-функціональних-компонентах)
  - [useEffect з пустим масивом залежностей](#useeffect-з-пустим-масивом-залежностей)
  - [useEffect зі змінними в масиві залежностей](#useeffect-зі-змінними-в-масиві-залежностей)
  - [return value функції переданої в useEffect](#return-value-функції-переданої-в-useeffect)
  - [а як тоді імітувати `shouldComponentUpdate`?](#а-як-тоді-імітувати-shouldcomponentupdate)
- [ErrorBoundary](#errorboundary)

Перше що треба зрозуміти про життєвий цикл, це те, що пояснювати його на класах набагато простіше. Якими б застарілими та повільними класові компоненти не були, кожен з них мав усі потрібні методи життєвого циклу, роботу яких перевірити було максимально просто.

Тому пояснення основних важливих методів життєвого циклу буде наведено на прикладі класового компонента.

Далі, під кінець, уже розберемось шо з них і як працює для функціональних.

Кожен метод на кожній стадії представлений реальним методом класового компоненту, який реакт "смикатиме" у зазначений момент. Тобто знаючи ці методи, їх назви і моменти в які вони будуть викликані, ти отримуєш суперсилу - розуміння куди шо запхать залежно від того коли тобі потрібно шоби щось виконалось.

# Mounting

Це покишо не метод, а стадія життєвого циклу. Трошки вища абстракція над методами. Можеш собі уявляти це як групу методів.

Під час стадії mounting відбувається створення компонента та його відображення на сторінці. Це перший етап життєвого циклу компонента.

## constructor

шо тут пояснювать? перед тим як на екран шось виплюнуть, треба спочатку створити екземпляр компоненту.

як ти створюєш екземпляр об'єкта в js? правильно, через конструктор. тут все так само.

конструктор викликається один раз, в самому початку життя компоненту. тут можна ініціалізувати стейт, або зробити щось інше, що треба зробити один раз при створенні екземпляру.

```jsx
class MyComponent extends Component {
  constructor(props) {
    super(props) //оця штука викликає конструктор "батьківського" компоненту, тобто реактівського Component
    this.state = {
      //тут можна ініціалізувати стейт
    }
  }
}
```

## static `getDerivedStateFromProps`

Просто візьми і переклади назву, більшість суті вона пояснює самостійно без додаткових втручань.

Цей метод викликається перед рендером, коли компонент отримує нові пропси. Він повертає новий стейт, який буде використаний для оновлення стейту компонента.

`static` - лише означає, що для виклику цього методу не потрібно створювати екзеспляр класу. Можна вилкикати через крапку після імені класу.

використовувався дуже рідко, коли треба втрутитись в процес оновлення стейту, який відбувається після отримання нових пропсів.

## render

з назви, знову таки має бути очевидно шо відбувається.

з цікавого:

- єдиний обовʼязковий метод у класового компонента
- не завершиться, поки не завершаться рендери всі дочірніх компонентів

```jsx
class MyComponent extends Component {
  render() {
    return <div>{/* тут відображається компонент */}</div>
  }
}
```

## componentDidMount

досить популярний метод, викликається один раз, після того як компонент відобразився на сторінці.

зазвичай перший рендер компонента відбуваєтсья "впусту" без даних, потім викликається componentDidMount, де уже можна робити запити на сервер, і тільки потім відбувається оновлення стейту, яке призведе до другого рендеру з даними.

```jsx
class MyComponent extends Component {
  componentDidMount() {
    //тут можна робити запити на сервер, або щось інше, що треба зробити після того як компонент відобразився на сторінці
  }
  render() {
    return <div>{/* тут відображається компонент */}</div>
  }
}
```

# Updating

методи даної стадії викликаються після одного з тригерів:

- зміни пропсів
- зміни стейту
- виклик `forceUpdate` - на практиці зустрічається так само часто, як чесні політики

## shouldComponentUpdate

з назви стає зрозуміло, шо від цього козака залежить чи дійсно буде оновлюватись компонент. тобто тут ти можеш втрутитись в процес порівняння стврих пропсів та нових, або стейту до і після оновлення.

якщо метод поверне `false`, компонент не буде оновлений.

```jsx
class MyComponent extends Component {
  shouldComponentUpdate(nextProps, nextState) {
    //тут можна втрутитись в процес оновлення компонента
    return true //повернути false, якщо не треба оновлювати компонент
  }
  render() {
    return <div>{/* тут відображається компонент */}</div>
  }
}
```

## componentDidUpdate

викликається після оновлення компонента. випадки його застосування досить рідкісні, бо важко видумать випадок коли тобі треба відправити запит на сервер, основуючись на тому що стейт або пропси апдейтнулись.

проте воно є, ним можна скористатись в класовому компоненті

# Unmounting

## componentWillUnmount

метод, в якому саме час відписуватись від підписок, видаляти таймери, або будь-які інші дії перед видаленням компонента зі сторінки.

# Шо по послідовностях?

Якшо ми забудемо про стадії, то послідовність спрацьовування методів приблизно така:

- constructor
- static `getDerivedStateFromProps`
- render
- componentDidMount

і середньостатистичний `stateless` компонент на цьому етапі тупо чекатиме тіки на `componentWillUnmount`.

але якщо ж помінялись пропси, або стейт, то кожного разу, кожної зміни наступна послідовність:

- static `getDerivedStateFromProps`
- shouldComponentUpdate
- render
- componentDidUpdate

# А як у функціональних компонентах?

тут все цікавіше і на мій особистий погляд трошки костильніше виглядає.

- по-перше усього різноманіття впливу як в класових компонентах - тут нема.

- по-друге - вся взаємодія з життєвим циклом сидить на використанні hook-а `useEffect`. від того що як і в якій послідовності ми в нього передаємо, змінюватиметься момент, коли переданий нами код спрацьовуватиме.

- по-третє - тіки присядь, бо впадеш. мільйони гайдів та відосів говоритимуть шо **користуватись `useEffect`-ом не можна**, що це минулий вік, що так уже ніхто не робить, що це шкодить продуктивності, лунним фазам Сатурна і таке інше.

  насправді ці ідіоти мають на увазі, що **запховувати `useEffect` безпосередньо в код компонента - це така собі ідея**.

  під капотом усіх рішень, які позбавляють тебе використання `useEffect`-у, насправді лежить...барабанний дріб...`useEffect`! та, це абсурд і маразм на перший погляд, проте памʼятай що ідея саме в тому, щоб винести `useEffect` за межі тіла компоненту, тоді вся ця богохульна магія виглядатиме набагато більш зрозумілою.

- по-четверте - `useEffect`-у треба ЗАВЖДИ передавати масив залежностей. хай навіть пустий, але другий аргумент має буть масив. інакше адекватної роботи від нього ти не дочекаєшся.

## useEffect з пустим масивом залежностей

`useEffect` з пустим масивом залежностей викликається тільки один раз, після першого рендеру компонента. тоюто повністю імітує поведінку `componentDidMount`.

```jsx
const MyComponent = props => {
  useEffect(() => {
    console.log('я в консолі буду тіки один раз після того як компонент відрендериться вперше')
  }, [/*пустий масив залежностей*/])

  return <p>
    Hello World
  </p>
```

## useEffect зі змінними в масиві залежностей

callbackб який ти передаєш в `useEffect` викликається кожного разу, коли змінюється хоча б одна змінна з масиву залежностей. тобто повністю імітує поведінку `componentDidUpdate`.

```jsx
const MyComponent = props => {
  const [count, setCount] = useState(0)

  useEffect(() => {
    console.log('я в консолі буду викликатись кожного разу, коли зміниться count')
  }, [count])

  return <p>
    <button onClick={() => setCount(count + 1)}>Click me</button>
  </p>
```

приклад, очевидно, нежиттʼздатний, проте направлений лише показати тобі як це працює. де приміняти цей прийом ти відпрацюєш на практиці трохи згодом.

## return value функції переданої в useEffect

функція, яку ти передаєш в `useEffect` може повертати ще одну функцію.

не питай нахєра так складно, це треба прийняти як аксіому. нахєра вони зробили це так "зручно" ніхто не знає.

так от ця друга функція, яку твій callback може повернути повністю імітуватиме `componentWillUnmount`.

```jsx
const MyComponent = props => {
  const [count, setCount] = useState(0)

  useEffect(() => {
    console.log('я в консолі буду викликатись кожного разу, коли зміниться count')

    /* оця функція і буде викликана на етапі Unmount */
    return () => {
      console.log('а я імітую componentWillUnmount')
    }
  }, [count])

  return <p>
    <button onClick={() => setCount(count + 1)}>Click me</button>
  </p>
```

## а як тоді імітувати `shouldComponentUpdate`?

для цього Боженька придумав `prevState`. це коли ти замість значення в `setState` передаєш функцію, яка приймає попередній стейт, і повертає новий.

```jsx
const MyComponent = props => {
  const [count, setCount] = useState(0)

  const handleIncrement = () => {
    /*бачиш, замість значення передаю функцію і творю там шо хочу у перевірках*/
    setCount(prevState => {
      if(prevState >= 100) return 0
      return prevState + 1
    })
  }

  return <p>
    <button onClick={handleIncrement}>Click me</button>
  </p>
```

також, для схожого ефекту можна використати `useMemo` або `useCallback`, але це вже зовсім інша історія.

# [ErrorBoundary](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)

а це штука, яку можна створити лише класовим компонентом, бо тільки він має метод `componentDidCatch`.

служить добру службу по красівому відображенню помилок в додатку, які користувачеві все ж мають бути показані.

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props)
    this.state = { hasError: false }
  }

  static getDerivedStateFromError(error) {
    // оновлюємо стейт для того, щоб потім відрендерити UI з помилкою
    return { hasError: true }
  }

  componentDidCatch(error, info) {
    // Example "componentStack":
    //   in ComponentThatThrows (created by App)
    //   in ErrorBoundary (created by App)
    //   in div (created by App)
    //   in App
    logErrorToMyService(error, info.componentStack) // це на віпадок, якщо у тебе є підключений сервіс із логуванням помилок
  }

  render() {
    if (this.state.hasError) {
      // це може бути будь яка розмітка зі стилями на твій смак
      return <h1>Something went wrong.</h1>
    }

    return this.props.children
  }

  logErrorToMyService() {
    // тут можна відправити помилку на сервер
  }
}
```

на практиці зустрічається, але зазвичай або автогенерується бандлером, або уже написаний до тебе. проте розуміти шо в ньому відбувається та чому потрібно, аби не ввести себе в оману шо магія існує.
