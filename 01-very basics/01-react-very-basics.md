# Що таке [React](https://react.dev/learn)

Зміст:

- [Що таке React](#що-таке-react)
  - [JavaScript-ліба, дла створення користувацьких інтерфейсів](#javascript-ліба-дла-створення-користувацьких-інтерфейсів)
- [фреймворк vs біблотека](#фреймворк-vs-біблотека)
- [create-react-app](#create-react-app)
  - [базова файлова структура:](#базова-файлова-структура)
- [Vite](#vite)
  - [базова файлова структура пресету `react`:](#базова-файлова-структура-пресету-react)
  - [додаткові відмінності](#додаткові-відмінності)
- [Virtual DOM](#virtual-dom)
  - [State](#state)
  - [Так зване "Примирення".](#так-зване-примирення)
- [JSX](#jsx)
  - [Особливості JSX розмітки](#особливості-jsx-розмітки)
- [Шо по стилям?](#шо-по-стилям)
- [React DevTools](#react-devtools)

### JavaScript-ліба, дла створення користувацьких інтерфейсів

Є ва варіанти говорити про реакт:

1. Саме як про _лібу_ - тоді мається н аувазі саме біблотека, npm-пакет, який сам по собі звісно дуже корисний, але якщо ти захочеш писать проєкт використовуючи тільки її....ну...удачі. Бо всі інші красоти розробки веб-інтерфейсів на реакті повʼязані з тим шоб оточити _[react](https://react.dev/learn)_ мільйоном інших плюшок.
2. Як про _фреймворк_ - коли люди говорять про _[react](https://react.dev/learn)_ як про фреймворк, то частіше за все мають на увазі усю свору додаткових бібліотек, що поліпшують життя програмістам та прискорюють виконання тривіальних задач.

```
⚠️ називати [react](https://react.dev/learn) фреймворком технічно не правильно

все шо робить саме бібліотека [react](https://react.dev/learn) спрощено можна описати так - він рендерить компонент на сторінку та синхроніує його стан на екрані зі станом даних, що за ним закріплені.
```

# фреймворк vs біблотека

Осьо тобі визначення з вікіпедії:

```
Фреймворк (англ. Framework, каркас, платформа)

інфраструктура програмних рішень, що полегшує розробку складних систем.
Спрощено дану інфраструктуру можна вважати своєрідною комплексною бібліотекою,
але при цьому вона має ряд обмежень, що задають правила створення структури проєкту та написання коду.
```

Визначення, як на мене - шляпа. Тому ось тобі більш просте, для розуміння різниці між фреймворком та біблотекою.

`Бібліотека` - твій слуга. ТИ ВИРІШУЄШ які саме інструменти з неї де використовуватимеш та як на 100%, не обмежує тебе у файловій структурі та архітектурних рішеннях.

`Фреймворк` - твій господар. ТИ СЛУГА фреймворку, бо всі твої рішення приймаються у заздалегіть визначених архітектурних рамках, твоя програмістська воля обмежена зводом правил, які ти приймаєш починаючи користуватись ним.

Тому і вважається шо [react](https://react.dev/learn) - це НЕ фреймворк, бо це дуже корисна, але все ще бібліотека, яка потребує дуже багато "штукатурки" навколо себе для комфорної роботи. На протидію - [Vue](https://vuejs.org/), це прям повноцінний фреймворк зі своїми правилами та законами які не можна порушувати.

не дивлячись на таке визначення тема залишається холіварною, особливо з такими рішенями як [Creat-Creat-App](#create-react-app) та [Vite](#vite), які розмивають цю грань по відношенню до [react](https://react.dev/learn)-у.

# [create-react-app](https://create-react-app.dev/docs/getting-started)

Трохи застарілий та по теперішнім міркам повільний спосіб ініціалізувати проєкт з усіма потрібними базовими налаштуваннями, додатковими бібліотеками, блекджеком та хльондрами.

Зараз можна часто зустріти проєкти які саме з цією біблотекою збирались, але для створення нових більша частина фронтендного населення використовують дещо інше.

свого часу CRA дуже широко використовувалась.

### базова файлова структура:

- my-app/
  - `README.md` - тут все еочевидно наче
  - `node_modules/` - тут все еочевидно наче
  - `package.json` - тут все еочевидно наче
  - `public/` - тека, де лежить html та додаткові загальні картинки. не всі. лише загальні
    - `index.html`
    - `favicon.ico` - як от фавіконка.
  - `src/` - скорочення від слова source - вихідний код
    - `App.css` - стилі кореневого компоненту твого застосунку
    - `App.js` - код кореневого компоненту твого застосунку
    - `App.test.js` - файл з тестами кореневого компоненту твого застосунку
    - `index.css` - загальні стилі на увесь застосунку
    - `index.js` - тут зазавичай тіки пару рядків коду, що стосуються того в який ДОМ-елемент відрендерити твій застосунок
    - `logo.svg` - тут все еочевидно наче

# [Vite](https://vitejs.dev/guide/#trying-vite-online)

Більш швидка та "легка" альтернатива до CRA, що активно використовуєтсься для нових проєктів.

Так, вони дають пресети і для застосунків на VanillaJS, і VanillaTS, і звичайно на [react](https://react.dev/learn).

Вибираєш потрібний тобі пресет і погналися!

### базова файлова структура пресету `react`:

- `my-app/`
  - `README.md` - тут все еочевидно наче
  - `package.json` - тут все еочевидно наче
  - `vite.config.js` - конфігураційний файл. по суті ти налаштуваннями тут оверрайдиш налаштування webpack-у
  - `public/` - тека, де лежить html та додаткові загальні картинки. не всі. лише загальні
    - `vite.svg` - наче пояснень не треба що це
  - `index.html` - навідміну від складнозаплутаної теки `public/` тут твоя розмітка лежить в корньовій директорії проєкту
  - `.eslint.cjs` - конфігураційний файл такої штуки як [eslint](https://eslint.org/docs/latest/use/getting-started). детально про неї пізніше, але якшо коротко, то це ще один контролер шо стоїть над тобою і дає прочухана якшо ти написав якусь шляпу.
  - `src/` - скорочення від слова source - вихідний код
    - `assets/` - тут склад картинок, шрифтів, інших штук які потрібні на сторінці. ти потім можеш створити таку саму теку хоч в кодному компоненті, але загальна є осьо "з заводу".
      - `react.svg`
    - `App.css` - стилі кореневого компоненту твого застосунку
    - `App.js` - код кореневого компоненту твого застосунку
    - `index.css` - загальні стилі на увесь застосунку
    - `main.js` - тут зазавичай тіки пару рядків коду, що стосуються того в який

### додаткові відмінності

1. `node_modules` - після створення проєкту нема. це значить шо їх тре встановити. гайд тобі так і каже, але вирішив і тут нагадати шоб не було питань.
2. скрипти для "запуску" трошки інші по назвах:
   - `dev` - ним ти користуєшся в більшості випадків. запускає dev-сервер з твоїм проєктом і дає тобі адресу куда ломитись шоб побачити все в браузері
   - `build` - збирає твій проєкт щоб він займав якомога менше місця і був оптимізований для публікації "на прод"
   - `lint` - насильно прогоняє `elsint`-ом всі файліки шоб підсвітити тобі де ти дібил
   - `preview` - а це для того шоб заранить серіер, який буде зостити файли уже зібраного застосунку. тобто шоб ти перед публікацією "на прод" побачив як уже зібраний код вигляда в браузері

# [Virtual DOM](https://reactjs.org/docs/faq-internals.html#gatsby-focus-wrapper)

Посилання в заголовку на сайт який уже не оновлюється, але бляха кращої статті з поясненням шо це і нахєра я поки не знайшов.

`DOM` - ти уже знаєш. дерево елементів на сторінці, інтерфейс роботи з ними і таке інше.

`VirtualDOM` - істота трохи інша. можеш уявляти його собі як дбайливу бабусю, задача якої шоб до тебе в ротик потрапили тільки стиглі черешні без червʼяків. увесь зардворк по розумінню який саме елемент на екрані треба перерендерити та чи дійсно варто це робити відбувається саме там. ЦЕ КІЛЛЄР-ФІЧА [react](https://react.dev/learn)-у

### State

Для того шоб вся ця махінація стала можливою окрім розділення сторінки на компоненти, треба розуміти шо кожен компонент може мати якийсь свій стан.

Звучить до сраки абстрактно, згоден, але згадай як працює чекбокс. Він завжди знає чи він `checked` чи нє. От це і буде визначати **стан/`state`** чекбоксу. Якшо писать самостійно такий компонент, то в його `state` ти точно запишеш оцю властивість `checked`.

### Так зване ["Примирення"](https://www.educative.io/answers/what-is-the-concept-of-reconciliation-in-react).

Почитай посилання в заголовку, якщо хочеш прям зрозуміти як саме працює порівняння.

Ідейно порявняння/примирення DOM та VirtualDOM можна представити як:

- компонент ренджериться зі станом за замовчуванням, який ти йому дав
- відбувається зміна стану з тої чи іншої причини
- щоб відрендерити компонент з новим станом, на рівні VirtualDOM відбувається порівняння старого та нового дерева компонентів
- визначається які саме елементи змінилися
- тільки ці елементи перерендерються в DOM

весь цей процес відбувається дуже швидко, тому що VirtualDOM - це значно менший за розміром обʼєкт, ніж саме DOM-дерево та способи порівняння використовуються дуже ефективні.

> \* Наполегливо рекомендую подивитись оце [відео](https://www.youtube.com/watch?v=-x2HdZ5unH4&list=PLZ3MwD-soTTEm5KtB2AoZuM7fiYRR69k8&index=10&ab_channel=CallstackEngineers). Тут відносно простою мовою про те як і шо відбувається в VirtualDOM-і під час ренджеру компонентів. Не очікую шо все буде зрозуміло, проте для загального розуміння треба.

# [JSX](https://react.dev/learn#writing-markup-with-jsx)

Як можна було вже помітити, в розмітці файлу `index.html` ніц нема, окрім одного дівака, всередину якого буде відрендерене дерево твоїх компонентів.

А це значить шо? А це значить шо все шо ти бачиш в компонентах **ЦЕ НЕ HTML!!!**

Припустимо нема такого явища як [JSX](https://react.dev/learn#writing-markup-with-jsx).

Тоді щоб створити компонент з простим текстом всередині тобі треба буде писати щось накшталт:

```javascript
const HelloWorld = ({ toWhat }) =>
  React.createElement("p", null, `Hello ${toWhat}`)
```

І так для кожного елементу, який ти хочеш створити. Без виключень.

Зручно піпєц, чи не так?

Тому Боженька придумав [JSX](https://react.dev/learn#writing-markup-with-jsx) щоб твоя лінива дупця могла писати код, схожий на уже звичний тобі HTML, якнайменше думаючи про підкапотні JS-ні приколи.

Таким чином приклад зверху трансформується у:

```javascript
const HelloWorld = ({ toWhat }) => <p>`Hello ${toWhat}`</p>
```

Чи це дійсно зручніше та зрозуміліше - предмет окремих холіварних дискусій. Проте ми з тобою приймаємо це як "дано".

Те шо ми з тобою можемо постановити зі 100-ю впевненістю, це те шо **JSX - це ["синтаксичний цукор"](https://uk.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%BD%D0%B8%D0%B9_%D1%86%D1%83%D0%BA%D0%BE%D1%80)** над звичайним JS-ним кодом.

---

### Особливості JSX розмітки

1. щоб вставити JS-не значення всередину JSX розмітки використовуються `{`,`}` фігурні дужки. Таким чином замість:

   ```javascript
   element.innertext = `counter value - ${counterValue}`
   ```

   буде:

   ```JSX
   <p>counter value - {counterValue}</p>
   ```

   і так само з атрибутами:

   ```JSX
   <div data-tabNumber={currentTab}>...</div>
   ```

2. `JSX expressions must have one parent element`.
   Означає шо ти маєш ЗАВЖДИ ПОВЕРТАТИ ОДИН ТЕГ, всередині якого буде уже все що тобі потрібно.

   Якщо в твому компоненті є дла тега `<p>`, то доведеться загортати їх у `<div>`.
   Так, це створить дуже багато завйих елементів і може ускладнити стилізацію.

   Тому Боженька придумав `<Fragment>...</Fragment>` або просто `<>...</>` - цей компонент виконує ту саму функцію що і [DocumentFragment](https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment) в ДОМ-і, тобто він міститиме в собі всі елементи, але в розмітку не потрапить.

3. Атрибути, які в HTML писались використовуючи `kebab-case` тепер треба писати використовуючи `camelCase`.

   Тобто звичні тобі атрибути не зміняться - `id`,`class`, `type`, тощо писатимуться так само, тому воно тебе майже не торкнеться.

4. Атрибут `class` - так як в JS-і це зарезервоване слово, яке відноситься до синтаксичної конструкції класу, тобі доведеться звикнути писати `className`. Тому там де HTML був:

```html
<p class="user-name">Gogi</p>
```

JSX стане:

```html
<p className="user-name">Gogi</p>
```

---

# Шо по стилям?

А шо хочеш то і буде. Всі варіанти стилізації зустрічаються, по-різному і в різних комбінаціях.

1. `Pure CSS` - це те, як зазавичай створюються ініціалізаційні файли проєкту. Нічого підключати не треба, все знайоме і тд.
2. `SASS`/`SCSS` - в залежності від того як ти ставишся до фігурних дужок. Що [Vite](#vite), що [CRA](#create-react-app) підтримують цю двіжуху. Частіше за все треба буде встановити додатково пакет `node-sass` або споріднений йому, дока підкаже який саме.
3. [`CSS Modules`](https://css-tricks.com/css-modules-part-1-need/) - працюють як для чистого CSS так для пре-процесорів. Замість того шоб писать назви класів строками, ти можеш використовувать їх і звертатись до імпортованого обʼєкту де кожна властивість це створений тобою CSS клас. Ще один плюс використання - інкапсуляція. Назви класів хешуються і тому майже нульова вірогідність їх повторення, навіть якшо імена в CSS файлі будуть однакові.

# [React DevTools](https://react.dev/learn/react-developer-tools#browser-extension)

Дуже корисна штука. Ти бачитимеш все дерево компонентів, саме компонентами з їх state-ом та props-ами, що часто економить тонни часу на етапі дебагінгу не тільки початківцям.
